
General Purpose I / O (GPIO)


14.1 Introduction

범용 I / O (GPIO) 주변 장치는 MIO 모듈을 통해 최대 54 개의 장치 핀을 관찰하고 

제어 할 수있는 소프트웨어를 제공합니다.

또한 EMI (Programmable Logic)에서 64 개의 입력에 액세스하고 EMIO 인터페이스를 통해 

PL로 128 개의 출력을 제공합니다.

GPIO는 관련 인터페이스 신호를 그룹화하는 4 개의 레지스터 뱅크로 구성됩니다

각 GPIO는 입력, 출력 또는 인터럽트 감지와 같이 독립적으로 동적으로 프로그래밍됩니다.

소프트웨어는 단일로드 명령을 사용하여 뱅크 내의 모든 GPIO 값을 읽거나 단일 저장 명령을 사용하여 

하나 이상의 GPIO (GPIO 범위 내)에 데이터를 쓸 수 있습니다.

GPIO 제어 및 상태 레지스터는 기본 주소 0xE000_A000에 메모리 매핑됩니다


14.1.1 Features

GPIO 주변 장치의 주요 기능은 다음과 같이 요약됩니다.

- 장치 핀용 54 개의 GPIO 신호 (MIO 멀티플렉서를 통해 라우팅 됨) 

	- 출력은 3 상태 가능 

- EMIO 인터페이스를 통해 PS와 PL 간 192 GPIO 신호 

	- 64 개의 입력, 128 개의 출력 (64 개의 실제 출력 및 64 개의 출력 가능)

- 각 GPIO의 기능은 개별 또는 그룹 단위로 동적으로 프로그래밍 할 수 있습니다

- 활성화, 비트 또는 뱅크 데이터 쓰기, 출력 활성화 및 방향 제어

- 개별 GPIO 기반의 프로그래밍 가능한 인터럽트 

	- 원시 및 마스크 된 인터럽트의 상태 읽기 

	- 선택 가능한 감도 : 레벨 감지 (높음 또는 낮음) 또는 가장자리 감지 (양수, 음수 또는 모두)


14.1.2 Block Diagram Notices 


그림 14-1과 같이 GPIO 모듈은 4 개의 뱅크로 나뉩니다 :

- Bank0 : MIO 핀을 제어하는 32 비트 뱅크 [31:0]

- Bank1 : MIO 핀을 제어하는 22 비트 뱅크 [53:32]: MIO에는 총 54 개의 핀이 있으므로 Bank1은 22 비트로 제한됩니다.

- Bank2 : EMIO 신호를 제어하는 32 비트 뱅크 [31:0]

- Bank3 : EMIO 신호를 제어하는 32 비트 뱅크 [63:32]

GPIO는 일련의 메모리 매핑 레지스터를 통해 소프트웨어에 의해 제어됩니다.

각기 다른 기능으로 인해 MIO 은행과 EMIO 은행간에 사소한 차이가 있지만 각 은행에 대한 통제는 동일합니다.


14.1.3 Notices


7z007s 및 7z010 CLG225 장치

7z007s 싱글 코어 및 7z010 듀얼 코어 CLG225 디바이스는 

섹션 2.5.4 MIO-at-a-Glance Table의 MIO 테이블에서 볼 수 있듯이 사용 가능한 MIO 핀을 32로 줄입니다. 

따라서 이들 장치에서 MIO에 사용할 수있는 유일한 GPIO 핀은 15:0, 39:28, 48, 49, 52 및 53입니다. 

다른 MIO 핀은 연결되지 않았으므로 사용하지 않아야합니다. 

모든 EMIO 신호를 사용할 수 있습니다.


MIO 고려 사항

GPIO 주변 모듈의 뱅크 0과 1은 MIO 모듈을 통해 장치 핀으로 라우팅됩니다.

MIO 작동에 대한 자세한 설명은 섹션 2.5 PS-PL MIO-EMIO 신호 및 인터페이스를 참조하십시오.
 
MIO의 기본 제어는 slcr.MIO_PIN_xx 레지스터를 통해 수행됩니다.

다음 사항에 유의하십시오.

- 사용자는 사용자 시스템에 따라 IO_Type, PULLUP, DisableRcvr 및 Speed 필드를 사용하여 적절한 

  I / O 유형을 선택해야합니다.

- 사용자는 멀티플렉서 제어 필드 L0_SEL, L1_SEL, L2_SEL 및 L3_SEL을 통해 GPIO 모듈을 선택해야합니다. 

  각 I / O 핀은 개별적으로 선택할 수 있습니다. MIO 핀이 IOP 장치 용으로 사용되면 GPIO로 사용할 수 없습니다.

- TRI_ENABLE을 0으로 설정해야합니다. 이렇게하면 GPIO가 I / O의 3- 상태 모드를 제어 할 수 있습니다.

  MIO에서 TRI_ENABLE이 1로 설정된 경우 출력 드라이버는 GPIO 설정에 관계없이 3 진입니다.


14.2 Functional Description


14.2.1 GPIO Control of Device Pins

이 절에서는 Bank0 및 Bank1의 작동에 대해 설명합니다


소프트웨어는 GPIO를 출력 또는 입력으로 구성합니다. 

DATA_RO 레지스터는 GPIO가 입력 (OE 신호 거짓) 또는 출력 (OE 신호 참)으로 설정되었는지 여부에 관계없이 항상 GPIO 핀의 상태를 반환합니다. 

출력 파형을 생성하기 위해 소프트웨어는 하나 이상의 GPIO에 반복적으로 기록합니다 (일반적으로 MASK_DATA 레지스터 사용).

응용 프로그램은 동시에 두 개 이상의 GPIO를 전환해야 할 수도 있습니다 (두 개의 I / O 버퍼 사이의 고유 한 비뚤어 짐 시간이 적음). 

이 경우, 동시에 스위칭해야하는 모든 GPIO는 MASK_DATA 레지스터를 활성화하기 위해 

동일한 16 비트 하프 뱅크 (즉, 최상위 16 비트 또는 최하위 16 비트)에서 GPIO를 가져와야합니다 

하나의 저장 명령으로 그것들에 쓰는 것.


GPIO 뱅크 제어 (Bank0 및 Bank1)는 다음과 같이 요약됩니다.

- DATA_RO :이 레지스터는 소프트웨어가 장치 핀의 값을 관찰 할 수있게합니다. 

	   GPIO 신호가 출력으로 구성된 경우 일반적으로 출력에서 구동되는 값을 반영합니다. 이 레지스터에 대한 쓰기는 무시됩니다. 

참고 : MIO가 이 핀을 GPIO 핀으로 사용하도록 구성되지 않은 경우 소프트웨어가 GPIO 레지스터를 통해 

	비 GPIO 핀의 값을 관찰 할 수 없기 때문에 DATA_RO는 예측할 수 없습니다.


- DATA :이 레지스터는 GPIO 신호가 출력으로 구성 될 때 출력 할 값을 제어합니다. 

	이 레지스터의 모든 32 비트는 한 번에 기록됩니다. 이 레지스터를 읽으면 이전 값이 DATA 또는 MASK_DATA_ {LSW, MSW}에 기록됩니다. 

	장치 핀의 현재 값을 반환하지 않습니다. 


- MASK_DATA_LSW :이 레지스터는 원하는 출력 값을보다 선택적으로 변경할 수 있습니다. 최대 16 비트의 모든 조합을 쓸 수 있습니다. 

		 기록되지 않은 비트는 변경되지 않고 이전 값을 유지합니다. 

		 이 레지스터를 읽으면 이전 값이 DATA 또는 MASK_DATA_ {LSW, MSW}에 기록됩니다. 장치 핀의 현재 값을 반환하지 않습니다. 

		 이 레지스터는 변경되지 않은 비트에 대한 읽기 - 수정 - 쓰기 시퀀스의 필요성을 피합니다. 


- MASK_DATA_MSW :이 레지스터는 뱅크의 상위 16 비트를 제어한다는 점을 제외하고는 MASK_DATA_LSW와 동일합니다. 


- DIRM : 방향 모드. 이것은 I / O 핀이 입력 또는 출력으로 작동하는지 여부를 제어합니다. 

	 입력 로직은 항상 활성화되어 있기 때문에 출력 드라이버를 효과적으로 활성화 / 비활성화 할 수 있습니다. 

	 DIRM [x] == 0이면 출력 드라이버가 사용되지 않습니다. 


- OEN : 출력 가능. I / O가 출력으로 구성되면 출력이 활성화되는지 여부를 제어합니다. 출력이 디스 에이블되면 핀은 3 진법이다. 

  OEN [x] == 0 일 경우, 출력 드라이버가 비활성화됩니다. 

참고 : MIO TRI_ENABLE이 1로 설정되고 3 상태를 활성화하고 드라이버를 비활성화하면 OEN은 무시되고 출력은 3 진술됩니다


14.2.2 EMIO Signals


이 절에서는 Bank2 및 Bank3의 작동에 대해 설명합니다 (그림 14-2 참조).


EMIO 뱅크의 레지스터 인터페이스는 이전 섹션에서 설명한 MIO 뱅크와 동일합니다. 

그러나 EMIO 인터페이스는 PS와 PL 사이의 단순한 연결이기 때문에 몇 가지 차이점이 있습니다.

- 입력은 PL의 와이어이며 출력 값 또는 OEN 레지스터와 관련이 없습니다. DIRM이 0으로 설정되면 DATA_RO 레지스터에서 값을 읽을 수 있습니다.

- 출력 와이어는 3 상태를 지원하지 않으므로 OEN의 영향을받지 않습니다. 

  출력 될 값은 DATA, MASK_DATA_LSW 및 MASK_DATA_MSW 레지스터를 사용하여 프로그래밍됩니다. DIRM은 1로 설정해야 출력됩니다.

- 출력 인 에이블 와이어는 PS의 단순한 출력입니다. 

  EMIO는 다음과 같이 DIRM / OEN 레지스터에 의해 제어됩니다 : 

  EMIOGPIOTN [x] = DIRM [x] & OEN [x] EMIO I / O는 어떤 식 으로든 MIO I / O에 연결되지 않습니다.

  EMIO 입력은 MIO 출력에 연결할 수 없으며 MIO 입력은 EMIO 출력에 연결할 수 없습니다. 

  각 뱅크는 독립적이며 소프트웨어 관찰 가능 / 제어 가능한 신호로만 사용할 수 있습니다


14.2.3 Bank0, Bits[8:7] are Outputs 

Bank0의 GPIO 비트 [8:7]는 리셋 중에 I / O 버퍼 자체의 전압 모드를 제어하는 데 사용되는 패키지 핀에 해당합니다. 

이 핀을 MIO 뱅크 용 VMODE 핀 스트랩이라고 부릅니다 (165 페이지 부팅 모드 핀 설정 참조). 

이들은 적절한 전압 모드에 따라 외부 시스템에 의해 구동되어야합니다. 

다른 시스템 로직에 의해 구동되지 않도록 범용 입력으로 사용할 수 없습니다.

리셋시 출력 드라이버가 비활성화되므로이 비트는 범용 출력으로 사용할 수 있습니다. 

시스템은 시스템 부팅 중에 전압 모드를 읽은 후 이들을 출력으로 사용할 수 있습니다.


14.2.4 Interrupt Function

인터럽트 감지 로직은 GPIO 입력 신호를 모니터링합니다. 

인터럽트 트리거는 포지티브 에지, 네거티브 에지, 양쪽 에지, 로우 레벨 또는 하이 레벨이 될 수 있습니다. 

트리거 감도는 INT_TYPE, INT_POLARITY 및 INT_ANY 레지스터를 사용하여 프로그래밍됩니다.

인터럽트가 감지되면 GPIO의 INT_STAT 상태는 인터럽트 감지 로직에 의해 true로 설정됩니다. 

INT_STAT 상태가 활성화 (마스크 해제)되어 있으면 인터럽트가 큰 OR 함수로 전달됩니다. 

인터럽트 마스크 상태는 INT_EN 및 INT_DIS 레지스터에 1을 쓰면 제어됩니다. I

NT_EN 레지스터에 1을 쓰면 활성 인터럽트가 인터럽트 컨트롤러에 전파 될 수 있도록 마스크가 비활성화됩니다. 

INT_DIS 레지스터에 1을 쓰면 마스크가 활성화됩니다. 인터럽트 마스크의 상태는 INT_MASK 레지스터를 사용하여 읽을 수 있습니다.

GPIO 인터럽트가 에지에 민감한 경우 INT 상태는 감지 로직에 의해 래치됩니다. INT 래치는 INT_STAT 레지스터에 1을 쓰면 클리어됩니다. 

레벨에 민감한 인터럽트의 경우 인터럽트 신호를 지우려면 GPIO에 대한 인터럽트 입력 소스를 지워야합니다. 

또는 소프트웨어는 INT_DIS 레지스터를 사용하여 해당 입력을 마스킹 할 수 있습니다.

인터럽트 컨트롤러로가는 인터럽트 신호의 상태는 INT_STAT 및 INT_MASK 레지스터를 읽음으로써 추론 할 수 있습니다. 

이 인터럽트 신호는 INT_STAT = 1 및 INT_MASK = 0이면 어설 션됩니다

이 기능은 네 개의 모든 뱅크에있는 모든 GPIO에 대한 모든 인터럽트를 인터럽트 컨트롤러에 대한 하나의 출력 (IRQ ID # 52)에 결합합니다. 

인터럽트가 비활성화 (마스크)되면 INT_STAT 상태는 지워질 때까지 유지되지만 나중에 

INT_EN이 마스크를 비활성화하도록 작성되지 않으면 인터럽트 컨트롤러로 전파되지 않습니다. 

모든 GPIO가 동일한 인터럽트를 공유하기 때문에 소프트웨어는 어떤 GPIO가 인터럽트를 일으키는 지 

확인하기 위해 INT_MASK와 INT_STAT를 모두 고려해야합니다. 

GPIO 뱅크 제어는 다음과 같이 요약됩니다.

- INT_MASK :이 레지스터는 읽기 전용이며 현재 비트가 마스크되고 마스크되지 않았 음을 나타냅니다.

- INT_EN :이 레지스터의 비트에 1을 쓰면 해당 신호가 인터럽트를 활성화 / 비활성화됩니다. 이 레지스터를 읽으면 예측할 수없는 값이 반환됩니다.

- INT_DIS :이 레지스터의 비트에 1을 쓰면 인터럽트 신호가 마스크됩니다. 이 레지스터를 읽으면 예측할 수없는 값이 반환됩니다.

- INT_STAT : 인터럽트 이벤트 발생 여부를 나타내는 레지스터입니다. 이 레지스터의 비트에 1을 쓰면 해당 비트의 인터럽트 상태가 지워집니다. 
	    
 	     이 레지스터의 비트에 0을 쓰는 것은 무시됩니다.

- INT_TYPE :이 레지스터는 인터럽트가 에지 감지인지 또는 레벨 감지인지를 제어합니다.

- INT_POLARITY :이 레지스터는 인터럽트가 활성 (Low) 또는 활성 (High) (또는 하강 에지 감지 또는 상승 에지 감지) 여부를 제어합니다.

- INT_ON_ANY : INT_TYPE을 에지 감지로 설정하면 이 레지스터는 상승 및 하강 에지에서 인터럽트 이벤트를 활성화합니다. 

	       INT_TYPE이 레벨 감지로 설정된 경우이 레지스터는 무시됩니다

14.3 Programming Guide


GPIO 컨트롤러에는 MIO 및 EMIO에 각각 2 개의 4 개의 뱅크가 있습니다. 각 GPIO 핀은 개별적으로 프로그래밍 할 수 있습니다. 

(14.2.1)절의 "디바이스 핀의 GPIO 제어"에서 설명한 것처럼 다중 핀을 단일 쓰기로 프로그래밍 할 수 있습니다.


14.3.1 Start-up Sequence 

주요 예 : 시동 순서

1. 리셋 : 리셋 옵션은 14.4.2 리셋에서 설명합니다.

2. 클럭 : 클럭은 14.4.1 절에 설명되어 있습니다.

3. GPIO 핀 구성 : 핀을 입력 / 출력으로 구성하는 방법은 14.3.2 GPIO 핀 구성에서 설명합니다.

4. GPIO 출력 핀에 데이터 쓰기 : 14.3.3 GPIO 출력 핀에 데이터 쓰기의 예를 참조하십시오.

5. GPIO에서 데이터 읽기 입력 핀 : 14.3.4 GPI에서 데이터 읽기의 예를 참조하십시오.


14.3.2 GPIO Pin Configuration

각 개별 GPIO 핀은 입력 / 출력으로 구성 될 수 있습니다. 그러나 bank0 [8:7] 핀은 출력으로 구성되어야합니다. 

자세한 내용은 14.2.3 절을 참조하십시오. 비트 [8:7]은 출력입니다.

예 : MIO 핀 10을 출력으로 구성

1. 방향을 출력으로 설정하십시오 : gpio.DIRM_0 레지스터에 0x0000_0400을 씁니다.

2. 출력 인 에이블을 설정합니다 : gpio.OEN_0 레지스터에 0x0000_0400을 씁니다. 

참고 : 출력 인 에이블은 GPIO 핀이 출력으로 구성된 경우에만 중요합니다

예 : MIO 핀 10을 입력으로 구성

1. 방향을 입력으로 설정하십시오 : gpio.DIRM_0 레지스터에 0x0을 씁니다. 그러면 gpio.DIRM_0 [10] = 0이 설정됩니다.


14.3.3 Writing Data to GPIO Output Pins


출력으로 구성된 GPIO 핀의 경우 원하는 값을 프로그래밍하는 두 가지 옵션이 있습니다.

옵션 1 : gpio.DATA_0 레지스터를 사용하여 GPIO 핀을 읽고, 수정하고, 업데이트하십시오.

예 : DATA_0 레지스터를 사용하여 GPIO 출력 핀 10을 설정합니다.

1. gpio.DATA_0 레지스터를 읽습니다. gpio.DATA_0 레지스터를 reg_val 변수에 읽습니다.

2. 값을 수정하십시오. Set reg_val [10] = 1.

3. 출력 핀에 업데이트 된 값 쓰기 : gpio.DATA_0 레지스터에 reg_val을 씁니다.

옵션 2 : 하나 이상의 GPIO 핀을 업데이트하려면 MASK_DATA_x_MSW / LSW 레지스터를 사용하십시오.


예 : MASK_DATA_0_MSW 레지스터를 사용하여 출력 핀 20, 25 및 30을 1로 설정합니다.

1. 핀 20, 25 및 30에 대한 마스크 값 생성 : 20, 25 및 30 핀을 구동하기 위해 0xBDEF는 gpio.MASK_DATA_0_MSW [MASK_0_MSW]의 마스크 값입니다.

2. 핀 20, 25, 30에 대한 데이터 값 생성 : 핀 20, 25 및 30에서 1을 구동하려면 0x4210이 gpio.MASK_DATA_0_MSW [DATA_0_MSW]의 데이터 값입니다.

3. 마스크와 데이터를 MASK_DATA_x_MSW 레지스터에 씁니다. gpio.MASK_DATA_0_MSW 레지스터에 0xBDEF_4210을 씁니다.


14.3.4 Reading Data from GPIO Input Pins


입력으로 구성된 GPIO 핀의 경우 입력을 모니터링하는 두 가지 옵션이 있습니다.

옵션 1 : 각 뱅크의 gpio.DATA_RO_x 레지스터를 사용하십시오.

예 : DATA_RO_0 레지스터를 사용하여 뱅크 0의 모든 GPIO 입력 핀 상태를 읽습니다.

1. 입력 뱅크 읽기 0 : gpio.DATA_0 레지스터를 읽습니다. 선택권

2 : 입력 핀에 인터럽트 로직을 사용하십시오 (14.2.4 절 인터럽트 기능 참조).

예 : 상승 에지로 트리거되도록 MIO 핀 12를 구성합니다.

1. 트리거를 상승 에지로 설정합니다. gpio.INT_TYPE_0 [12]에 1을 씁니다.
 
   gpio.INT_POLARITY_0 [1]에 1을 씁니다. gpio.INT_ANY_0 [12]에 0을 씁니다.

2. 인터럽트 활성화 : gpio.INT_EN_0 [12]에 1을 씁니다.

3. 입력 핀의 상태 : gpio.INT_STAT_0 [12] = 1은 인터럽트 이벤트가 발생했음을 의미합니다.

4. 인터럽트 비활성화 : gpio.INT_DIS_0 [12]에 1을 씁니다.


14.3.5 GPIO as Wake-up Event


GPIO는 웨이크 업 장치로 구성 될 수 있습니다.

중요 : GIC는 올바르게 설정해야합니다.

1. GIC에서 GPIO 인터럽트를 활성화합니다.

2. gpio.INT_EN_ {0..3} 레지스터를 사용하여 원하는 핀에 대한 GPIO 인터럽트를 활성화합니다. 

   1을 gpio.INT_EN_0 [10]으로 설정하여 GPIO10 인터럽트를 활성화합니다.

3. GPIO 관련 클럭을 끄지 마십시오.


14.3.6 Register Overview

GPIO 레지스터의 개요는 표 14-2 (14.2.1절의 장치 핀의 GPIO 제어 섹션 참조)에 나와 있습니다. 

레지스터의 세부 사항은 부록 B, 레지스터 세부 사항에서 제공됩니다.


14.4 System Functions

컨트롤러 클록 및 리셋에 대해서는이 절에서 설명합니다. GPIO 컨트롤러에서 생성 된 모든 인터럽트는 IRQ 52로 라우팅됩니다. 

GPIO I / O 신호는 MIO 또는 EMIO로 라우팅됩니다. 


14.4.1 Clocks

컨트롤러는 APB 인터페이스에서 CPU_1x 클록으로 클럭됩니다. 모든 출력 및 입력 샘플링은 CPU_1x 클럭을 사용하여 수행됩니다
.
전원 관리를 위해 slcr.APER_CLK_CTRL [GPIO_CPU_1XCLKACT]을 사용하여 GPIO 컨트롤러 클럭에 클록 게이팅을 사용할 수 있습니다.


14.4.2 Resets

컨트롤러는 slcr.GPIO_RST_CTRL [GPIO_CPU1X_RST] 비트에 의해 재설정됩니다. 자세한 내용은 Chapter26, Reset System을 참조하십시오. 

이 리셋은 컨트롤러 로직 자체가 아니라 버스 인터페이스에만 영향을줍니다.


14.4.3 Interrupts

컨트롤러 인터럽트는 14.2.4 절 인터럽트 기능에서 설명합니다. 컨트롤러는 GIC에 IRQ # 52를 지정합니다. 

프로그래밍 예제는 14.3.4 GPIO 입력 핀에서 데이터 읽기 섹션에 설명되어 있습니다.



14.5 I/O Interface


14.5.1 MIO Programming 


뱅크 0 및 뱅크 1 핀은 MIO를 통해 라우팅됩니다. 이 핀은 slcr.MIO_PIN_XX 레지스터를 사용하여 GPIO로 구성 될 수 있습니다.


예 : MIO 핀 6을 GPIO 신호로 구성

1. GPIO로 MIO 핀을 선택하십시오 : L0_SEL, L1_SEL, L2_SEL, L3_SEL = 0을 설정하십시오.

2. TRI_ENABLE = 0으로 설정하십시오.

3. LVCMOS18 (다른 전압 옵션의 레지스터 정의 참조).

4. CMOS 가장자리가 느려집니다.

5. 내부 풀업 저항을 활성화하십시오.

6. HSTL 수신자를 비활성화하십시오.

참고 : TRI_ENABLE = 1 인 경우 GPIO 설정에 관계없이 출력이 3 진입니다. TRI_ENABLE = 0이면 3 상태는 gpio.OEN_x 레지스터에 의해 제어됩니다. 



