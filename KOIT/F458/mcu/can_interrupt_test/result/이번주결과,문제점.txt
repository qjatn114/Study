
ppt구성 순서
1.freertos 태스크 생성부분과 스케줄링시작

기본 구조
cap코드: 우선 조건문을 통하여 ch3과 ch4를 분리해서 처리 각각은 처음에 과도하게 인터럽트가 들어오는 것을 막기 위하여 interrupt를 disable 시킨 뒤에 bldc태스크와 servo태스크에 notify로 깨움.
bldc,서보:각각은 실제 모터를 구동하는 부분의 코드로 후진시나 값의 범위를 조정하는 부분의 코드 그리고 pwm을 출력하기 위해 레지스터에 값을 할당하는 부분으로 구성


can송수신테스트 
계기:나중에 dsp를 붙여서 학습을 시킬때에 can과 cap이 동시에 들어오는 환경에서 정상적으로 통신을 할 수 있는가?
인터럽트가 수행되는 환경에서 각각의 태스크는 명령들을 놓치지 않고 실행 할 수 있는 가?

테스트 환경 구현
pid태스크:실제 완성된 차량에서는 pid를 할 예정이었으므로 추가 bldc태스크에 notify를 보내어 bldc모터를 동작시킴 
딱히 하는 일이 없는 태스크를 추가함.
UART출력부분 sciDisplay부분을 이진세마포어를 걸고 테스트

예상못한 문제 발생:
인터럽트가 스케줄링 하기도 전에 발생하여 비정상 동작=>인터럽트 관련 페리페럴들을 초기화하는 태스크를 만들어서 처리.


결과 1차.(4태스크 3인터럽트 사진)
문제점:태스크들이 UART출력 도중 인터럽트가 제어를 뺏고 출력하여 태스크들이 제대로 출력하지 못함

인터럽트 비활성화 기능이 있는 criticalSection  함수들을 추가

결과 2차. (can 10ms, 100ms, 200ms)
태스크들이 제대로 수행되지못하고 can 인터럽트만 수행되는 결과 발생
원인:UART자원을 놓고 경쟁이 발생하여 병목되고 출력자체가 굉장히 느린 연산.

UART출력을 제거하고 can통신으로 대체
추가:canrecv:인터럽트가 빈번하게 발생하는 상황에서 태스크들이 can신호를 놓치지 않고 수행할 수 있는가를 태스트

can 송수신 테스트

1.can receive interrupt에서 notify를 통해 task가 응답받아 ecap으로부터 받은 값을 can에 보내기
인터럽트가 빈발하는 상황하에서 태스크의 실행이 얼마나 보장되는지 한 테스트.

20ms:표기된 카메라 스펙이 초당 50프레임=> 1장당 20ms=> 1frame당 반응하기 위해선 최소 20ms마다 명령이 들어와야함.

IRQ(1만번씩 테스트)
20ms:10007/10039=99.68%
15ms:10139/10168=99.71%
10ms:6471/10122=63.93%


FIQ
20ms:10106/10113=99.93%
15ms:10025/10027=99.98%
10ms:9413/10074=93.43

20ms쯤 부터 태스크들의 동작은 0.3%가량 보장이 안됨
10ms부터는 굉장히 심각해짐

인터럽트 핸들러에서 전송시의 결과:(ISR 10만1ms)
100541/100543=99.998%


해결방안 task의 기능들을 인터럽트 핸들러로 가져오고 nested interrupt로 처리함.
nested interrupt문서에서 IRQ와 FIQ간에는 nested interrupt가 된다고 한 내용을 봤음.
사진(IRQvsFIQ)=>IRQ중 FIQ가 발생하여 진입하지만 FIQ가 끝난 후에 복귀 실패.

nested interrupt구현 필요.

다른 문제점 발생
pwm주기는 20ms 정확하게 1주기의 pwm주기를 출력하기 위해서는 그 2배인 40ms의 딜레이가 필요.
심지어 현재 사용중인 변속기에서는 1번 입력한 신호를 제대로 인식하기 위해서는 약 100ms가 필요.(후진 테스트)
최초 후진의 경우 약 400ms의 딜레이가 발생함.
=>설령 20ms 마다 dsp명령을 할 지라도 모터와 변속기는 반응이 불가능.


