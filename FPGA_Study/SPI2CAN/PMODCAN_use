MCP25625를 초기화한다. 
초기화 함수에 가면 맨 처음 Reset을 한다.
SPI interface
RESET주소는 0xC0이다.

do_msg()함수에서 reset명령을 한다. do_msg()는 PMOD device에 명령을 보내는 함수같다. 
ioctl 시스템콜에서 SPI_IOC_MESSAGE(2)를 통해 read write를 한다. 이건 chip select 때문에 write 하고 read하면
문제가 있다고 하여(반이중) 전이중 방식인 것 같다.

그 다음 setCANCTRL_MODE함수를 실행시킨다. (매개변수로 0x80) 이 함수에서 다시 modifyRegister함수실행 (매개변수로 MCP_CANCTRL(0x0F), MODE_MASK(0x80), MCPMODE(0x80)넘겨준다. 이 함수에서 MCP_BITMOD,MCP_CANCTRL,MCP_MASK, configuration mode를 설정한다. BITMOD는 특정 레지스터의 개별 비트를 설정할 수 있다.
즉 modifyRegister함수는 레지스터의 특정 비트를 설정한다.

그리고 readRegister()함수를 실행한다 . 매개변수로 CANCTRL(0x0F)넘겨준다.
이 함수에서 SPI 인터페이스인 READ(0x03) 명령으로 선택한 주소에서 읽어온다.
그리고 읽어온 값을 리턴하여 MCP_MASK와 &연산 한다. 같으면 1을 반환한다.

이 함수로 Configuration mode로 설정하고 BitRate를 세팅한다.
250KBPS, 20MHZ로 설정하기 위해 configRate()함수에 매개변수로 4(250KBPS),0(20MHZ)을 넘겨준다.

그리고 CNF1(0x2A), CNF2(0x29), CNF3(0x28) 의 주소를 가지고 setRegister()함수에 매개변수 값들을 넣어 do_msg함수로 디바이스에 넣는다.

그리고 initCANBuffers()함수 실행한다. 여기서는 TX,RX버퍼에 0으로 초기화를 해준다.

버퍼 초기화 후 configuration MODE에서 이제 normal MODE로 바꾼다.
그리고 초기화는 끝난다.

그리고 메세지를 보낸다.
-----------------------------------------------------------------------------------------------
<TX>
1. 먼저 처음 1byte는 TXxCTRL 설정한다. (TXREQ)
2. 5byte는 standard mode/ extended mode 정보와 다른 메세지 중재 정보를 저장하는데 사용하고 마지막 8byte는 데이터이다.
	(TXBxSIDH, TXBxSIDL, TXBxEID8, TXBxEID0, TXBxDLC) 
 	TXBxSIDL레지스터의 EXIDE=1은 Extended, 0은 Standard/ 0,1비트는 Extended bits이다. DLC는 데이터길이
3. 최소한 TXBxSIDH,TXBxSIDL,TXBxDLC,TXBxDn(보낼 데이터가 있으면)레지스터를 로드해야한다.
	(Extended를 사용한다면 TXBxEIDn레지스터를 로드하고 TXBxSIDL레지스터의 EXIDE=1이어야 한다)
4. 메세지를 보내기전 CANINTE레지스터의 TXxIE비트를 초기화하여 비활성화/활성화 해야한다.
5. 송신버퍼에 기록하기 전 TXBxCTRL레지스터의 TXREQ비트를 클리어 해야한다.
	(보내고 나면 자동으로 클리어 된다?)
	1)SPI WRITE 명령을 통해 레지스터에 쓰기.
	2)SPI RTS 명령 보내기
	3)전송할 특정 전송 버퍼 (들)에 대해 TxnRTS 핀을 로우로 설정하기.
6. 전송이 성공적으로 완료되면 TXREQ 비트가 지워지고 CANINTF 레지스터의 TXxIF 비트가 설정되며 CANINTE 레지스터의 TXxIE 비트가 설정되면 인터럽트가 생성됩니다.

7. 전송완료하면 TXxIF=1 된다?

TXBxCTRL 레지스터에서 TXREQ 비트를 설정해도 메시지 전송은 시작되지 않습니다. 단순히 메시지 버퍼에 전송할 준비가되었음을 표시합니다. 장치가 버스를 사용할 수 있음을 감지하면 전송이 시작됩니다.


-----------------------------------------------------------------------------------------------
<Rx>

RXB0CTRL 레지스터에서 RXM0,1비트
Extended ID Filter register, RXFxEID8, RXFxEID0 레지스터들은 Standard ID가 있는 메세지의 데이터의 처음 2바이트에 적용된다.

수신버퍼 RXB0 RXB1은 MAB를 통해 메세지를 수신할 수 있다.
메세지가 수신되면 MAB의 전체 내용이 수신버퍼로 이동한다.
즉, Extended유형이든 Standard유형과 수신된 데이터 바이트 수에 관계없이 전체 수신 버퍼가 MAB내용으로 덮어 씌어진다.
따라서 버퍼에 있는 모든 레지스터의 내용은 메세지를 수신할 떄 수정된 것으로 가정해야한다.

메세지가 수신버퍼 중 하나로 이동하면 CANINTF레지스터의 RXxIF=1된다.
새 메세지를 버퍼에 수신하려면 RXxIF=0으로 해야한다.

CANINTE레지스터의 RXxIE=1되면 INT핀에 인터럽트가 생성되었다는 것이다. 즉 메세지가 수신되었다.
또한 Receive Buffer Full핀으로 구성된 경우 관련 RxnBF핀이 LOW로 구동된다.

RXB0 또는 RXB1에 메세지가 수신되었음을 나타내기 위한 Receive Buffer Full Pin이 있다.(Rx0BF, Rx1BF)
Receive Buffer Full Pin은 세가지 구성이 있다.
1)Disabled
2)Buffer Full Interrupt
3)Digital Output

RxnBF 핀은 버퍼 풀 인터럽트 핀 또는 표준 디지털 출력으로 작동하도록 구성 할 수 있습니다. (BFPCTRL)
인터럽트 모드 (BFPCTRL 레지스터의 BxBFE 및 BxBFM 비트 설정)로 작동하도록 설정되면이 핀은 액티브 로우이며 각 수신 버퍼에 대한 CANINTF 레지스터의 RXxIF 비트에 매핑됩니다.

이 비트가 수신 버퍼 중 하나에 대해 하이가되면 (유효한 메시지가 버퍼에로드되었음을 나타냄) 해당 RxnBF 핀이 로우가된다.
MCx에 의해 RXxIF 비트가 클리어되면, 다음 메시지가 수신 버퍼에로드 될 때까지 해당 인터럽트 핀이 로직 하이 상태가됩니다.


필터기준!!!!!!
<필터,마스크>
메시지 수용 필터와 마스크는 메시지 어셈블리 버퍼의 메시지를 수신 버퍼 중 하나에로드해야하는지 결정하는 데 사용됩니다 (그림 3-9 참조).

유효한 메시지가 MAB로 수신되면 메시지의 식별자 필드가 필터 값과 비교됩니다. 일치하는 것이 있으면 해당 메시지가 해당 수신 버퍼에로드됩니다.



RXM<1:0> 11은 수락필터 상관없이 어떤 메세지든 수신
00이면 

1. 초기화
2. reset (TX와 설정값이 같다)
3. CONFIG MODE로 설정한다( TX와 설정값이 같다)
4. BaudRate 설정 (250KBPS,20MHZ) (TX와 설정값이 같다)
5. Buffer 초기화( TX와 RX 설정값이 같다) 여기서 RXCTRL 모든 비트를 0으로 세팅.
6. RX 인터럽트, 플래그 설정


-------------------------------------------------------------------------------------------------
아두이노에서 spi_readwrite() 함수를 do_msg()로 한다. 즉 pmod device에 레지스터에 접근하려면 do_msg()를
사용한다.

레지스터 값을 읽어오는 함수는 readRegister()함수이다.
txbuf = TXB0SIDH

