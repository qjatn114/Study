- 두 개의 수신 버퍼
- Six Filters and Two Masks with Optional Filtering on the First Two Data Bytes
(첫 번째 두 데이터 바이트에 선택적 필터가있는 여섯 개의 필터와 두 개의 마스크)
- 버퍼 풀 및 요청 송신 핀은 범용 I / O로 구성 가능







<MODES OF OPERATION>
CAN 컨트롤러에는 5 가지 작동 모드가 있습니다
1) Configuration mode
2) Normal mode
3) Sleep mode
4) Listen-Only mode
5) Loopback mode

작동 모드는 CENTRAL 레지스터의 REQOP <2 : 0> 비트를 통해 선택됩니다 (레지스터 4-34 참조)
모드를 변경할 때 보류중인 모든 메시지 전송이 완료 될 때까지 모드가 실제로 변경되지 않습니다.
요청 된 모드는 CANSTAT 레지스터의 OPMOD <2 : 0> 비트를 읽음으로써 검증되어야한다 (레지스터 4-35 참조).


<CAN Transceiver Modes of Operation>
CAN 트랜시버에는 두 가지 작동 모드가 있습니다.
• 일반 모드
• 대기 모드
정상 모드는 STBY 핀에 로우 레벨을인가함으로써 선택된다.드라이버 블록이 작동하며 버스 핀을 구동 할 수 있습니다.
CANH 및 CANL의 출력 신호 경사는 최소의 전자파 방출 (EME)을 생성하도록 최적화되어 있습니다.
고속 차동 수신기가 활성화됩니다.
대기 모드는 STBY 핀에 하이 레벨을 적용하여 선택된다. 대기 모드에서 송신기와 수신기의 고속 부분은 전력 소비를 최소화하기 위해 꺼집니다. 저전력 수신기와 웨이크 업 필터는 버스 활동을 모니터링하기 위해 작동된다.
수신 핀 (R XD)은 웨이크 업 필터로 인해 CAN 버스의 지연된 표현을 보여줍니다.


<Configuration Mode>
MCP25625는 활성화전에 초기화해야합니다. 이는 장치가 구성 모드에있는 경우에만 가능합니다.
CANCTRL 레지스터에 REQOPx 비트를 설정하여 전원 켜기, 재설정 또는 다른 모드에서 입력 할 수있는 구성 모드가 자동으로 선택됩니다. 구성 모드가 시작되면 모든 오류 카운터가 지워집니다. 구성 모드는 다음 레지스터를 수정할 수있는 유일한 모드입니다.
• CNF1, CNF2, CNF3
• TXRTSCTRL
• Acceptance Filter registers



<Normal Mode>
일반 모드는 MCP25625의 표준 작동 모드입니다. 이 모드에서 장치는 모든 버스 메시지를 능동적으로 모니터링하고 확인 비트, 오류 프레임 등을 생성합니다.
이는 또한 MCP25625가 CAN 버스를 통해 메시지를 전송하는 유일한 모드입니다.


<Sleep/Standby Mode>
CAN 컨트롤러는 디바이스의 전류 소모를 최소화하기 위해 사용되는 내부 휴면 모드를 가지고 있습니다.
SPI 인터페이스는 MCP25625가 슬립 모드에 있더라도 읽기를 위해 활성 상태를 유지하므로 모든 레지스터에 액세스 할 수 있습니다.

슬립 모드는 CANCTRL 레지스터의 REQOPx 비트를 통해 선택됩니다. CANSTAT 레지스터의 OPMODx 비트는 동작 모드를 나타낸다. 이 비트는 MCP25625에 SLEEP 명령을 보낸 후에 읽어야합니다. MCP25625는 활성화되어 있으며이 비트가 슬립 모드로 들어갈 때까지 슬립 모드로 들어 가지 않았습니다.

Sleep 모드에있을 때 MCP25625는 내부 발진기를 정지시킵니다. MCP25625는 버스 동작이 발생하거나 마이크로 컨트롤러가 SPI 인터페이스를 통해 설정할 때 웨이크 업한다. CANINTF 레지스터의 WAKIF 비트는 웨이크 업 시도를 "생성"합니다 (웨이크 업 인터럽트가 발생하려면 CANINTE 레지스터의 WAKIE 비트도 설정해야합니다).

트랜시버의 낮은 대기 전류를 이용하려면 CAN 트랜시버가 대기 모드 여야합니다. 웨이크 업 후에 마이크로 컨트롤러는 STBY 핀을 사용하여 트랜시버를 다시 정상 모드로 전환해야한다.



<WAKE-UP FUNCTIONS>
CAN 트랜시버는 CAN 버스를 모니터링하여 작업을 수행합니다. 송수신기 내부의 웨이크 업 필터는 잡음으로 인한 웨이크 업을 피할 수 있습니다. CAN 버스에서 동작이 발생하면 R XD 핀이 로우가된다. CAN 버스 웨이크 업 기능은 CAN 트랜시버 전원 전압이 V DDA 및 V IO와 같은 유효한 범위에 있어야합니다.
********************
CAN 컨트롤러는 RxCAN 핀의 하강 에지를 감지하고 웨이크 업 인터럽트가 활성화되면 마이크로 컨트롤러를 인터럽트한다.
*******************
Sleep 모드에서 내부 발진기가 셧다운되기 때문에 발진기가 시작되고 장치가 메시지를 수신 할 수 있도록하는 데 어느 정도의 시간이 걸립니다.
이 오실레이터 시작 타이머 (OST)는 128 T OSC로 정의됩니다. 장치는 절전 모드에서 깨어나 기 시작한 메시지와 장치가 "깨어 난다"발생하는 메시지를 무시합니다. 장치는 청취 전용 모드로 작동을 시작합니다.
MCP25625가 버스에서 통신 할 수 있으려면 마이크로 컨트롤러가 CAN 컨트롤러와 CAN 트랜시버를 모두 일반 모드로 설정해야합니다.


<Listen-Only Mode>
Listen_Only Mode는 RXBxCTRL 레지스터의 RXM <1 : 0> 비트를 구성하여 MCP25625가 모든 메시지 (오류가있는 메시지 포함)를 수신 할 수있는 방법을 제공합니다. 이 모드는 버스 모니터 응용 프로그램이나 "핫 플러깅 (hot plugging)"상황에서 보드 율을 감지하는 데 사용할 수 있습니다.
DS20005282B-page 8 자동 보드 감지 (ABD)의 경우, 적어도 두 개의 다른 노드가 서로 통신해야합니다.
유효한 메시지가 수신 될 때까지 다른 값을 테스트하여 경험적으로 보오율을 감지 할 수 있습니다.
청취 전용 모드는 무음 모드로,이 모드 (오류 플래그 또는 확인 신호 포함) 중에는 메시지가 전송되지 않습니다.
청취 전용 모드에서는 RXBxCTRL 레지스터의 필터 및 마스크 또는 RXM <1 : 0> 비트와 관계없이 유효 및 무효 메시지가 수신됩니다. 오류 카운터는이 상태에서 재설정 및 비활성화됩니다. 청취 전용 모드는 CANCTRL 레지스터에 REQOPx 비트를 설정하여 활성화됩니다.


<Loopback Mode>



<CAN CONTROLLER>
CAN 컨트롤러는 CAN 프로토콜 버전 2.0B를 구현합니다. ISO 11898-1 표준과 호환됩니다.

그림 3-1은 CAN 컨트롤러의 블록 다이어그램입니다. CAN 컨트롤러는 다음 주요 블록으로 구성됩니다.
CAN protocol engine
TX handler
RX handler
SPI interface
Control logic with registers and interrupt logic
I/O pins
Crystal oscillator


<CAN Module>
CAN 프로토콜 엔진은 TX 및 RX 핸들러와 함께 CAN 버스에서 메시지를 수신하고 전송하는 데 필요한 모든 기능을 제공합니다. 
********************
메시지는 먼저 적절한 메시지 버퍼 및 제어 레지스터를로드하여 전송됩니다. 
전송은 SPI 인터페이스를 통한 제어 레지스터 비트를 사용하거나 전송 인 에이블 핀을 사용하여 시작된다. 
********************
상태 및 오류는 해당 레지스터를 읽음으로써 확인할 수 있습니다. CAN 버스에서 감지 된 모든 메시지는 오류가 있는지 검사 한 다음 사용자 정의 필터와 대조하여 두 개의 수신 버퍼 중 하나로 이동해야하는지 확인합니다.



<Control Logic>
제어 논리 블록은 MCP25625의 설정 및 작동을 제어하며 레지스터를 포함합니다.
시스템 유연성을 높이기 위해 인터럽트 핀이 제공됩니다. 
***************************
유효한 메시지가 수신 버퍼 중 하나로 로드되었음을 나타내는 데 사용할 수있는 수신 레지스터 각각에 대한 하나의 다목적 인터럽트 핀 (특정 인터럽트 핀은 물론)이 있습니다. 특정 인터럽트 핀의 사용은 선택 사항입니다.
SPI 인터페이스를 통해 액세스되는 상태 레지스터뿐 아니라 범용 인터럽트 핀을 사용하여 유효한 메시지가 수신 된시기를 결정할 수 있습니다.
******************************
또한 세 개의 전송 레지스터 중 하나에로드 된 메시지의 즉각적인 전송을 시작할 수있는 세 개의 핀이 있습니다. SPI 인터페이스를 통해 액세스되는 제어 레지스터를 사용하여 메시지 전송을 개시 할 수도 있기 때문에이 핀의 사용은 선택 사항입니다.



<SPI Protocol Block>
마이크로 컨트롤러는 SPI 인터페이스를 통해 디바이스와 인터페이스한다. 레지스터는 SPI READ 및 WRITE 명령을 사용하여 액세스 할 수 있습니다. 특수화 된 SPI 명령은 SPI 오버 헤드를 줄입니다.



<CAN Buffers and Filters>
MCP25625에는 3 개의 송신 버퍼와 2 개의 수신 버퍼, 2 개의 수신 마스크 (수신 버퍼 당 하나) 및 총 6 개의 수신 필터가 있습니다.



<CAN Protocol Engine>
- PROTOCOL FINITE STATE MACHINE
엔진의 핵심은 Finite State Machine (FSM)입니다.
FSM은 TX / RX 시프트 레지스터, CRC 레지스터 및 버스 라인 간의 순차 데이터 스트림을 제어하는 ​​시퀀서입니다. 또한 FSM은 오류 관리 논리 (EML) 및 TX / RX 시프트 레지스터와 버퍼 간의 병렬 데이터 스트림을 제어합니다. FSM은 수신, 중재, 전송 및 오류 신호 처리가 CAN 프로토콜에 따라 수행되도록 보장합니다. 버스 라인에서 메시지의 자동 재전송도 FSM에 의해 처리됩니다.

- CYCLIC REDUNDANCY CHECK
CRC (Cyclic Redundancy Check) 레지스터는 제어 필드 (0 데이터 바이트가있는 메시지의 경우) 또는 데이터 필드 다음에 전송되고 수신 메시지의 CRC 필드를 확인하는 데 사용되는 순환 중복 검사 (CRC) 코드를 생성합니다.

- ERROR MANAGEMENT LOGIC
오류 관리 논리 (EML)는 CAN 장치의 오류 감금을 담당합니다. 두 개의 카운터 인 REC (Receive Error Counter)와 TEC (Transmit Error Counter)는 비트 스트림 프로세서의 명령에 의해 증가 및 감소됩니다. 에러 카운터의 값에 따라 CAN 컨트롤러는 에러 활성, 에러 패시브 또는 버스 오프 상태로 설정됩니다.

- BIT TIMING LOGIC
BTL (Bit Timing Logic)은 버스 라인 입력을 모니터링하고 CAN 프로토콜에 따라 버스 관련 비트 타이밍을 처리합니다. BTL은 CAN 컨트롤러 자체가 도미넌트 비트 (재 동기화)를 전송하지 않는 경우, 프레임 시작 (하드 동기화) 및 추가 RTS (Recessive-to-Dominant) 버스 라인 전환시 Recessive-to-Dominant 버스 전환에 동기화됩니다.
BTL은 또한 전파 지연 시간, 위상 시프트를 보상하고 비트 시간 내에 샘플 포인트의 위치를 ​​정의 할 수있는 프로그래밍 가능한 시간 세그먼트를 제공합니다. BTL의 프로그래밍은 보드 율 및 외부 물리적 지연 시간에 따라 다릅니다.


-----------------------------------------------------------------------------------------------



<TRANSMIT BUFFERS>
MCP25625는 3 개의 전송 버퍼를 구현합니다.
이들 각각의 버퍼는 14 바이트의 SRAM을 차지하며 디바이스 메모리 맵에 맵핑된다.
첫 번째 바이트 인 TXBxCTRL은 메시지 버퍼와 관련된 제어 레지스터입니다.
이 레지스터의 정보는 메시지가 전송되는 조건을 결정하고 메시지 전송 상태를 나타냅니다 (레지스터 4-1 참조).
5 바이트는 표준 및 확장 식별자와 다른 메시지 중재 정보 (레지스터 4-3에서 4-7 참조)를 저장하는 데 사용됩니다. 마지막 8 바이트는 메시지의 8 개의 가능한 데이터 바이트에 대한 것입니다 (레지스터 4-8 참조).

최소한 TXBxSIDH, TXBxSIDL 및 TXBxDLC 레지스터를로드해야합니다. 데이터 바이트가 메시지에 있으면 TXBxDn 레지스터도로드해야합니다. 메시지가 확장 식별자를 사용하는 것이라면, TXBxEIDn 레지스터도로드되어야하고 TXBxSIDL 레지스터의 EXIDE 비트가 설정되어야합니다.


************
메시지를 보내기 전에 마이크로 컨트롤러는 CANINTE 레지스터의 TXxIE 비트를 초기화하여 메시지가 전송 될 때 인터럽트 생성을 활성화하거나 비활성화해야합니다.

TXBxCTRL 레지스터의 TXREQ 비트는 송신 버퍼에 쓰기 전에 송신 버퍼가 전송 대기 중이 아님을 나타내야한다.

************
 
<TRANSMIT PRIORITY>
전송 우선 순위는 보류중인 전송 가능 메시지의 CAN 컨트롤러 내 우선 순위입니다. 이는 CAN 프로토콜에 내장 된 메시지 중재 체계에 암시 된 모든 우선 순위와는 독립적이며 반드시 관련이 없습니다.

SOF (Start-of Frame)를 보내기 전에 전송을 위해 대기중인 모든 버퍼의 우선 순위가 비교됩니다.

우선 순위가 가장 높은 전송 버퍼가 먼저 전송됩니다. 예를 들어, 송신 버퍼 0이 송신 버퍼 1보다 높은 우선 순위 설정을 갖는 경우, 버퍼 0이 먼저 전송됩니다.
두 개의 버퍼가 동일한 우선 순위 설정을 갖는 경우 가장 높은 버퍼 번호를 가진 버퍼가 먼저 전송됩니다.
예를 들어, 송신 버퍼 1이 송신 버퍼 0과 동일한 우선 순위 설정을 갖는 경우, 먼저 버퍼 1이 전송됩니다.
TXBxCTRL 레지스터의 TXP <1 : 0> 비트 (레지스터 4-1 참조)는 각 송신 버퍼에 대해 개별적으로 네 가지 레벨의 전송 우선 순위를 선택할 수있게 해준다. TXPx 비트가 '11'인 버퍼는 가능한 가장 높은 우선 순위를 가지며 TXPx 비트가 '00'인 버퍼는 가능한 최저 우선 순위를 갖습니다.

<INITIATING TRANSMISSION> 변속기 작동
메시지 전송을 시작하려면 전송할 각 버퍼에 대해 TXBxCTRL 레지스터의 TXREQ 비트를 설정해야합니다. 이것은 다음과 같이 수행 할 수 있습니다.
• SPI WRITE 명령을 통해 레지스터에 쓰기.
• SPI RTS 명령을 보냅니다.
• 전송할 특정 송신 버퍼에 대해 TxnRTS 핀을 로우로 설정.
SPI 인터페이스를 통해 전송이 시작되면 TX REx 비트는 TXPx 우선 순위 비트와 동시에 설정 될 수 있습니다.TXREQ가 설정되면 TXBxCTRL 레지스터의 ABTF, MLOA 및 TXERR 비트가 자동으로 소거됩니다.
***********
TXBxCTRL 레지스터에서 TXREQ 비트를 설정해도 메시지 전송은 시작되지 않습니다.
단순히 메시지 버퍼에 전송할 준비가되었음을 표시합니다. 장치가 버스를 사용할 수 있음을 감지하면 전송이 시작됩니다.

전송이 성공적으로 완료되면 TXREQ 비트가 지워지고 CANINTF 레지스터의 TXxIF 비트가 설정되며 CANINTE 레지스터의 TXxIE 비트가 설정되면 인터럽트가 생성됩니다.

메시지 전송이 실패하면 TXREQ 비트가 설정된 상태로 유지됩니다.
메시지가 전송 대기 중이며 다음 조건 플래그 중 하나가 설정됨을 나타냅니다.

- 메시지가 전송되기 시작했지만 오류 조건이 발생하면 TXBxCTRL 레지스터의 TXERR 비트와 CANINTF 레지스터의 MERRF 비트가 설정됩니다. CANINTE 레지스터의 MERRE 비트가 설정되면 INT 핀에 인터럽트가 발생한다.
- 중재가 손실되면 TXBxCTRL 레지스터의 MLOA 비트가 설정됩니다.

원샷 모드가 활성화 된 경우 (CANCTRL 레지스터의 OSM 비트) 위의 조건은 계속 존재합니다. 그러나 TXREQ 비트는 해제되고 메시지는 전송을 다시 시도하지 않습니다.

***********

<ONE-SHOT MODE>
One-Shot 모드는 메시지가 한 번만 전송되도록합니다. 일반적으로 CAN 메시지가 중재를 잃거나 오류 프레임에 의해 소멸되면 메시지가 재전송됩니다. One-Shot 모드를 사용하면 메시지가 중재 손실이나 오류 프레임과 상관없이 한 번만 전송하려고 시도합니다. One-Shot 모드는 TTCAN과 같은 결정 론적 시스템에서 시간 슬롯을 유지하는 데 필요합니다.


******************
<TxnRTS PINS>
TxnRTS 핀은 다음과 같이 구성 할 수있는 입력 핀입니다.
• Request-to-Send 입력 : 전송 버퍼 중 하나에서 메시지를 전송하는 대체 수단을 제공합니다.
• 표준 디지털 입력.

이 핀의 구성 및 제어는 TXRTSCTRL 레지스터를 사용하여 수행된다 (레지스터 4-2 참조). TXRTSCTRL 레지스터는 CAN 컨트롤러가 컨피규레이션 모드에있을 때만 수정할 수 있습니다 (2.0 "동작 모드"참조). Request-to-Send 핀으로 동작하도록 구성된 경우, 핀은 송신 버퍼 용 TXBxCTRL 레지스터의 해당 TXREQ 비트에 매핑된다. TXREQ 비트는 TxnRTS 핀의 하강 에지에 의해 래치된다. TxnRTS 핀은 RxnBF 핀이 로우가 될 때 자동으로 메시지 전송을 시작하기 위해 RxnBF 핀에 직접 연결될 수 있도록 설계되어있다.
TxnRTS 핀은 내부 풀업 저항 100kΩ (공칭)을 갖는다.
***********************

<ABORTING TRANSMISSION>
MCU는 연관된 TXREQ 비트를 지움으로써 특정 메시지 버퍼에서 메시지를 중단하도록 요청할 수있다.

또한 CANCTRL 레지스터의 ABAT 비트를 설정하여 보류중인 모든 메시지를 중단하도록 요청할 수 있습니다.

메시지 전송을 계속하려면이 비트를 재설정해야합니다 (일반적으로 TXREQ 비트가 해제 된 것으로 확인 된 후).
TXBxCTRL 레지스터의 ABTF 플래그는 CANCTRL 레지스터의 ABAT 비트를 통해 중단이 요청 된 경우에만 설정됩니다.
TXREQ 비트를 재설정하여 메시지를 중단하면 ABTF 비트가 설정되지 않습니다.

1)중단 요청시 전송중인 메시지는 계속 전송됩니다. 메시지가 전송을 성공적으로 완료하지 못하면 (즉, 중재가 손실되거나 오류 프레임에 의해 중단 된 경우) 오류가 중단됩니다.
2)One-Shot 모드가 활성화되면 오류 프레임 또는 중재 손실로 인해 메시지가 중단되면 TXBxCTRL 레지스터의 ABTF 비트가 설정됩니다.



<TRANSMIT MESSAGE FLOWCHART>

메시지 전송 순서는 장치가 전송 레지스터 중 하나에 대한 TXBxCTRL 레지스터의 TXREQ 비트가 설정되었다고 결정할 때 시작됩니다.

TXBxCTRL 레지스터가 설정된 상태에서 TXREQ 비트를 지우거나 메시지가 전송을 시작하기 전에 CANCTRL 레지스터의 ABAT 비트를 설정하면 메시지가 중단됩니다.

CANINTE 레지스터의 TXxIE 비트는 메시지가 성공적으로 전송 될 때 인터럽트가 생성되어야하는지 여부를 결정합니다.



***************************************************************
<Message Reception>  메세지 수신
메시지 수신에 필요한 레지스터는 4.2 절 "메시지 수신 레지스터"에 설명되어 있습니다.


- RECEIVE MESSAGE BUFFERING
MCP25625에는 각각 수용 필터를 여러 개 갖춘 2 개의 수신 버퍼가 있습니다. 세 번째 수신 버퍼 역할을하는 별도의 메시지 어셈블리 버퍼 (MAB)도 있습니다 (그림 3-6 참조).


- Message Assembly Buffer
세 개의 수신 버퍼 중 MAB는 항상 버스에서 다음 메시지를 수신하기 위해 최선을 다하고 있습니다.
MAB는 수신 된 모든 메시지를 어셈블합니다. 이러한 메시지는 수용 필터 기준이 충족되는 경우에만 RXBx 버퍼로 전송됩니다 (레지스터 4-12에서 4-17 참조).


- RXB0 and RXB1
RXB0 및 RXB1이라고하는 나머지 두 개의 수신 버퍼는 MAB를 통해 프로토콜 엔진에서 완전한 메시지를 수신 할 수 있습니다. MCU는 하나의 버퍼를 액세스 할 수있는 반면, 다른 버퍼는 메시지 수신 또는 이전에 수신 된 메시지를 유지하는 데 사용할 수 있습니다.

NOTE
메시지가 수락되면 MAB의 전체 내용이 수신 버퍼로 이동합니다. 즉, 식별자 유형 (표준 또는 확장)과 수신 된 데이터 바이트 수에 관계없이 전체 수신 버퍼가 MAB 내용으로 덮어 쓰여집니다.
따라서 버퍼에있는 모든 레지스터의 내용은 메시지를 수신 할 때 수정 된 것으로 가정해야합니다.


*******************************************
- Receive Flags/interrupts
메시지가 수신 버퍼 중 하나로 이동하면 CANINTF 레지스터의 해당 RXxIF 비트가 설정됩니다. 새 메시지를 버퍼에 수신하려면 이 비트를 MCU가 지워야합니다.
이 비트는 CAN 컨트롤러가 새로운 메시지를 수신 버퍼에로드하려고 시도하기 전에 MCU가 메시지를 완료했는지 확인하기 위해 긍정적 인 잠금 기능을 제공합니다.

CANINTE 레지스터의 RXxIE 비트가 설정되면 INT 핀에 인터럽트가 생성되어 유효한 메시지가 수신되었음을 나타냅니다. 또한 수신 버퍼 풀 핀으로 구성된 경우 관련 RxnBF 핀이 로우로 구동된다. 자세한 내용은 3.7.4 "Rx0BF 및 Rx1BF 핀"을 참조하십시오.


- RECEIVE PRIORITY
우선 순위가 더 높은 버퍼 인 RXB0에는 하나의 마스크와 두 개의 메시지 허용 필터가 연결되어 있습니다. 수신 된 메시지는 먼저 마스크에 적용되고 RXB0에 대한 필터가 먼저 적용됩니다.

RXB1은 우선 순위가 낮은 버퍼로 하나의 마스크와 4 개의 수용 필터가 연결되어 있습니다.

메시지가 RB0 마스크와 필터에 먼저 적용되는 것 외에도 수용 필터의 수가 적을수록 RXB0에서의 일치가 더 제한적이되며 해당 버퍼에 대해 더 높은 우선 순위가 부여됩니다.

메시지가 수신되면 RXBxCTRL <3 : 0> 비트는 수신을 활성화 한 수용 필터 번호와 수신 된 메시지가 원격 전송 요청인지 여부를 나타냅니다.


- Rollover
또한 RXB0CTRL 레지스터는 RXB0에 유효한 메시지가 포함되어 있고 다른 유효한 메시지가 수신되면 오버플로 오류가 발생하지 않고 RXB1의 승인 기준에 관계없이 새 메시지가 RXB1로 이동되도록 구성 할 수 있습니다.


- RXM<1:0> Bits
RXBxCTRL 레지스터의 RXM <1 : 0> 비트는 특수 수신 모드를 설정합니다. 정상적으로, 이들 비트들은 '00'으로 클리어되어 적절한 수용 필터들에 의해 결정되는 모든 유효한 메시지들의 수신을 가능하게한다.
이 경우 표준 또는 확장 메시지를 수신할지 여부는 RFXxSIDL 레지스터의 EXIDE 비트에 의해 결정됩니다.

RXMx 비트가 '11'로 설정된 경우 버퍼는 수락 필터의 값과 관계없이 모든 메시지를 수신합니다.

또한 메시지 끝에 EOF (End of Frame) 전에 오류가있는 경우 오류 프레임 전에 MAB에 어셈블 된 메시지 부분이 버퍼로로드됩니다. 이 모드는 CAN 시스템 디버깅에 약간의 가치가 있으며 실제 시스템 환경에서는 사용되지 않습니다.

RXMx 비트를 '01'또는 '10'로 설정하는 것은 권장되지 않습니다.


- START-OF-FRAME SIGNAL  시작 프레임 신호
활성화 된 경우 Start-of-Frame 신호는 RxCAN 핀에서 감지 된 각 CAN 메시지의 시작 부분에있는 SOF 비트에서 생성됩니다.

RxCAN 핀은 대기 - 중 - 우위 에지를 위해 유휴 버스를 모니터링합니다. 도미넌트 조건이 샘플 포인트까지 남아 있으면 MCP25625는이를 SOF로 해석하고 SOF 펄스가 생성됩니다. 도미넌트 조건이 샘플 포인트까지 남아 있지 않으면 MCP25625는 이것을 버스에서 글리치로 해석하고 SOF 신호가 생성되지 않습니다. 그림 3-5는 SOF 신호 및 글리치 필터링을 보여줍니다.

One-Shot 모드에서와 마찬가지로 SOF 신호용으로 TTCAN 유형 시스템을 사용합니다. 또한 RxCAN 핀과 SOF 비트를 모두 모니터링함으로써 MCU는 CAN 통신에 영향을 미치기 전에 작은 글리치를 감지함으로써 초기 물리적 버스 문제를 감지 할 수있다.


- Rx0BF AND Rx1BF PINS
다양한 조건에서 MCU에 인터럽트 신호를 제공하는 INT 핀 외에도 RXB0 또는 RXB1에 유효한 메시지가 각각로드되었음을 나타 내기 위해 수신 버퍼 풀 핀 (Rx0BF 및 Rx1BF)을 사용할 수 있습니다. 핀은 세 가지 다른 구성을 가지고 있습니다 (표 3-1 참조).
1. Disabled
2. Buffer Full Interrupt
3. Digital Output


- Disabled
RxnBF 핀은 BFPCTRL 레지스터의 BxBFE 비트를 클리어함으로써 하이 임피던스 상태로 디스 에이블 될 수있다.


- Configured as Buffer Full
RxnBF 핀은 버퍼 풀 인터럽트 핀 또는 표준 디지털 출력으로 작동하도록 구성 할 수 있습니다.
이 핀의 구성 및 상태는 BFPCTRL 레지스터 (레지스터 4-11)를 통해 사용할 수 있습니다. 인터럽트 모드 (BFPCTRL 레지스터의 BxBFE 및 BxBFM 비트 설정)로 작동하도록 설정되면이 핀은 액티브 로우이며 각 수신 버퍼에 대한 CANINTF 레지스터의 RXxIF 비트에 매핑됩니다. 이 비트가 수신 버퍼 중 하나에 대해 하이가되면 (유효한 메시지가 버퍼에로드되었음을 나타냄) 해당 RxnBF 핀이 로우가된다. MCx에 의해 RXxIF 비트가 클리어되면, 다음 메시지가 수신 버퍼에로드 될 때까지 해당 인터럽트 핀이 로직 하이 상태가됩니다.


- Configured as Digital Output
디지털 출력으로 사용될 때, BFPCTRL 레지스터의 BxBFM 비트는 클리어되어야하고 BxBFE 비트는 연관된 버퍼에 대해 설정되어야합니다. 이 모드에서 핀의 상태는 동일한 레지스터의 BxBFS 비트에 의해 제어됩니다. BxBFS 비트에 '1'을 쓰면 관련 버퍼 풀 핀에서 하이 레벨이 구동되고 '0'이면 핀이 로우로 구동된다. 이 모드에서 핀을 사용할 때 핀의 상태는 SPI BIT MODIFY 명령을 사용하여 버퍼 풀 핀 중 하나에서 글리치가 발생하는 것을 방지해야한다.


CONFIGURING RxnBF PINS
BnBFE  BnBFM  BnBFS  Pin Status
 0      X       X      Disabled, high-impedance
 1      1       X      Receive buffer interrupt
 1      0       0      Digital output = 0
 1      0       1      Digital output = 1



 - MESSAGE ACCEPTANCE FILTERS AND MASKS( 메세지 수락필터 및 마스크)
메시지 수용 필터와 마스크는 메시지 어셈블리 버퍼의 메시지를 수신 버퍼 중 하나에로드해야하는지 결정하는 데 사용됩니다 (그림 3-9 참조).
유효한 메시지가 MAB로 수신되면 메시지의 식별자 필드가 필터 값과 비교됩니다. 일치하는 것이 있으면 해당 메시지가 해당 수신 버퍼에로드됩니다.
메시지 필터링에 필요한 레지스터는 4.3 절 "수락 필터 레지스터"에 설명되어 있습니다.


- Data Byte Filtering
표준 데이터 프레임 (11 비트 식별자)을 수신하면 MCP25625는 확장 식별자와 일반적으로 연관된 16 비트의 마스크와 필터를 데이터 필드의 처음 16 비트 (데이터 바이트 0과 1)에 자동으로 적용합니다. 그림 3-8은 확장 된 데이터 프레임과 표준 데이터 프레임에 마스크와 필터를 적용하는 방법을 보여줍니다.
데이터 바이트 필터링은 첫 번째 데이터 바이트 (예 : DeviceNetTM)에서 필터링하는 상위 계층 프로토콜 (HLP)을 구현할 때 MCU의로드를 줄입니다.




------------
3.8
- CAN Bit Time
NBR (Nominal Bit Rate)은 CAN 버스에서 전송 된 초당 비트 수입니다 (수학 식 3-1 참조).

NOMINAL BIT RATE/TIME  NBR = 1/NBT

NBT (Nominal Bit Time)는 겹치지 않는 네 개의 세그먼트로 구성됩니다.
이들 각 세그먼트는 소위 Time Quanta (T Q)라는 정수로 구성됩니다.
각 Time Quantum의 길이는 발진기주기 (T OSC)를 기반으로합니다. 방정식 3-2는 Baud Rate Prescaler (BRP)를 사용하여 시간 퀀텀을 프로그래밍하는 방법을 보여줍니다.


---------------
3.11
 - Interrupt
MCP25625에는 8 개의 인터럽트 소스가 있습니다. CANINTE 레지스터는 각 인터럽트 소스에 대한 개별 인터럽트 인 에이블 비트를 포함합니다.
CANINTF 레지스터는 각 인터럽트 소스에 해당하는 인터럽트 플래그 비트를 포함합니다. 인터럽트가 발생하면 INT 핀은 MCP25625에 의해 로우로 구동되고 MCU에 의해 인터럽트가 클리어 될 때까지 로우로 유지된다. 각각의 조건이 여전히 지속되면 인터럽트를 지울 수 없습니다.


- INTERRUPT CODE BITS
보류중인 인터럽트의 소스는 레지스터 4-35에 표시된대로 CANSTAT 레지스터의 ICOD <2 : 0> (인터럽트 코드) 비트에 표시됩니다. 다중 인터럽트가 발생하는 경우 INT 핀은 모든 인터럽트가 MCU에 의해 리셋 될 때까지 로우 상태를 유지합니다. ICOD 비트는 현재 보류중인 가장 높은 우선 순위 인터럽트에 대한 코드를 반영합니다. 인터럽트는 내부적으로 우선 순위가 지정되므로 ICODx 값이 낮을수록 인터럽트 우선 순위가 높아집니다. 우선 순위가 가장 높은 인터럽트 조건이 해제되면 보류중인 (있는 경우) 다음으로 우선 순위가 높은 인터럽트의 코드가 ICODx 비트에 반영됩니다 (표 3-4 참조). 연관된 CANINTE 가능 비트가 설정된 인터럽트 소스 만 ICODx 비트에 반영됩니다.


 - TRANSMIT INTERRUPT
전송 인터럽트가 활성화되면 (CANINTE 레지스터에서 TXxIE = 1), 관련 송신 버퍼가 비워지고 새로운 메시지를로드 할 준비가되면 INT 핀에서 인터럽트가 생성됩니다.
CANINTF 레지스터의 TXxIF 비트는 인터럽트의 원인을 나타내도록 설정됩니다. 인터럽트는 TXxIF 비트를 지워서 지워집니다.


 - RECEIVE INTERRUPT
메시지의 송신 또는 수신 중에 에러가 발생하면, 메시지 에러 플래그 (CANINTF 레지스터의 MERRF 비트)가 설정되고, CANINTE 레지스터의 MERRE 비트가 설정되면 인터럽트가 INT 핀에 생성됩니다 . 이 기능은 Listen-Only Mode와 함께 사용할 때 보드 율을 용이하게하기 위해 사용됩니다.



- Oscillator
MCP25625는 크리스털 또는 세라믹 공진기를 OSC1 및 OSC2 핀에 연결하여 작동하도록 설계되었습니다.
MCP25625 오실레이터 설계에는 병렬 컷 크리스털이 필요합니다. 시리즈 컷 크리스털을 사용하면 크리스털 제조업체의 사양에서 벗어나는 빈도가 발생할 수 있습니다.
일반적인 발진기 회로가 그림 3-13에 나와 있습니다.
MCP25625는 그림 3-14 및 그림 3-15에서와 같이 OSC1 핀에 연결된 외부 클럭 소스에 의해 구동 될 수도 있습니다.

MCP25625는 MCP25625를 리셋 상태로 유지하는 발진기 스타트 업 타이머 (OST)를 사용하여 내부 상태 머신이 작동하기 전에 발진기가 안정화되었는지 확인합니다.
************************
OST는 파워 업 또는 슬립 모드에서의 웨이크 업이 발생한 후 처음 128 개의 OSC1 클럭 사이클 동안 리셋을 유지한다. OST가 만료 될 때까지 어떠한 SPI 프로토콜 동작도 시도되어서는 안된다는 점에 유의해야한다.
************************


 -CLKOUT Pin
CLKOUT 핀은 시스템 설계자에게 제공되어 메인 시스템 클럭 또는 시스템의 다른 디바이스를위한 클록 입력으로 사용됩니다. CLKOUT에는 내부 프리 스케일러가있어 F OSC를 1, 2, 4 및 8로 나눌 수 있습니다. CLKOUT 기능이 활성화되고 프리스케일러가 CANCTRL 레지스터를 통해 선택됩니다 (레지스터 4-34 참조).



 - Reset
MCP25625는 두 가지 리셋을 구별합니다.
1. H/w Reset : Low On Reset Pin
2. SPI Reset : SPI명령을 통해 리셋

이 두 재설정은 기능적으로 동일합니다. 로직 및 레지스터가 기본 상태가되도록 전원을 켠 후에이 두 가지 리셋 중 하나를 제공하는 것이 중요합니다.
RESET 핀에 ​​RC를 배치하여 하드웨어 리셋을 자동으로 수행 할 수 있습니다 (그림 3-16 참조).
이 값은 V DD가 동작 전압에 도달 한 후 최소 2 μs 동안 리셋 상태로 유지되어야하며, 전기적 사양 (t RL)에 명시되어 있어야한다.

-----------------------------------------------------------------------------------------------------

<SPI INTERFACE>
명령 및 데이터는 SI 핀을 통해 디바이스로 보내지며, SCK의 상승 에지에서 데이터가 클록 인된다.
데이터는 SCK의 하강 에지에서 MCP25625 (SO 라인)에 의해 구동된다. 어떤 동작이 수행되는 동안 CS 핀을 로우로 유지해야한다.

- LOAD TX BUFFER
전송 버퍼를로드 할 때 'abc'로 표시된 것처럼 6 개의 위치 중 하나에 주소 포인터를 배치하여 정상적인 WRITE 명령의 오버 헤드를 줄입니다.

- READ STATUS
송신 및 수신 기능을위한 여러 상태 비트를 읽는 빠른 폴링 명령.

- RX STATUS
수신 된 메시지의 필터 일치 및 메시지 유형 (표준, 확장 및 / 또는 원격)을 나타내는 빠른 폴링 명령.


NOTE : 연관된 RX 플래그 비트 (CANINTF 레지스터의 RX IF 비트)는 CS를 하이로 바꾼 다음에 클리어된다.
CS핀을 어떻게 다시 LOW로 하지?

<RESET insteruction>
RESET 명령을 사용하여 MCP25625의 내부 레지스터를 다시 초기화하고 구성 모드를 설정할 수 있습니다. 이 명령은 SPI 인터페이스를 통해 RESET 핀과 동일한 기능을 제공합니다. RESET 명령은 CS를 로우로 풀고 명령 바이트를 전송 한 다음 CS를 올려서 장치를 선택해야하는 1 바이트 명령어입니다. 전원 켜기 초기화 순서의 일부로 RESET 명령을 보내거나 RESET 핀을 낮추는 것이 좋습니다.


<READ instruction>
READ 명령은 CS 핀을 낮추어 시작합니다.
READ 명령은 MCP25625로 보내지고, 그 다음에 8 비트 주소 (A7에서 A0)가옵니다. 다음으로, 선택된 어드레스의 레지스터에 저장된 데이터는 SO 핀에서 쉬프트된다.
데이터의 각 바이트가 이동되면 내부 주소 포인터가 자동으로 다음 주소로 증가합니다.
따라서, 클록 펄스를 계속해서 제공함으로써 다음 연속 레지스터 어드레스를 판독하는 것이 가능하다.
이 방법을 사용하여 임의의 수의 연속 레지스터 위치를 순차적으로 읽을 수 있습니다. READ 동작은 CS 핀을 올려서 종료된다 (그림 5-2).

<READ RX instruction>READ RX BUFFER 명령 (그림 5-3)은 수신 버퍼의 주소를 빠르게 지정하여 읽을 수있게 해줍니다.
이 명령어는 SPI 오버 헤드를 1 바이트만큼 줄입니다. 주소 바이트. 명령 바이트에는 실제로 주소 포인터 위치를 결정하는 네 가지 값이 있습니다. 명령 바이트가 보내지면 컨트롤러는 READ 명령과 동일한 주소 위치에서 데이터를 클록 아웃합니다 (즉 순차적 읽기가 가능함). 이 명령은 명령이 끝날 때 CS가 발생하면 관련 수신 플래그 (CANINTF 레지스터의 RXxIF 비트)를 자동으로 지워 SPI 오버 헤드를 줄입니다.


<WRITE instruction>
WRITE 명령은 CS 핀을 내림으로써 시작된다.
WRITE 명령은 MCP25625로 보내지고 그 뒤에 주소와 적어도 1 바이트의 데이터가옵니다.
CS가 로우로 유지되는 한 데이터 바이트로 계속해서 클럭킹함으로써 순차 레지스터에 쓸 수 있습니다. 데이터는 실제로 D0 비트에 대한 SCK 라인의 상승 에지에서 레지스터에 기록됩니다. 8 비트가로드되기 전에 CS 라인이 하이가되면 해당 데이터 바이트에 대해 쓰기가 중단되고 명령의 이전 바이트가 기록됩니다. 바이트 WRITE 시퀀스에 대한보다 자세한 그림은 그림 5-4의 타이밍 다이어그램을 참조하십시오


<LOAD TX BUFFER instruction>
LOAD TX BUFFER 명령 (그림 5-5)은 일반 WRITE 명령에 필요한 8 비트 주소를 제거합니다. 8 비트 명령어는 6 개의 주소 중 하나에 주소 포인터를 설정하여 3 개의 전송 버퍼 중 하나의 "ID"또는 "데이터"주소를 가리키는 전송 버퍼에 빠르게 씁니다.


<RTS instruction>
RTS 명령은 하나 이상의 전송 버퍼에 대한 메시지 전송을 시작하는 데 사용될 수 있습니다.
MCP25625는 CS 핀을 낮춤으로써 선택된다. 그런 다음 RTS 명령 바이트가 전송됩니다. 그림 5-6에 나와있는이 명령의 마지막 세 비트는 전송할 수있는 전송 버퍼를 나타냅니다.
이 명령은 각 버퍼에 대한 TXBxCTRL 레지스터의 TXREQ 비트를 설정합니다. 마지막 3 비트 중 일부 또는 전부는 단일 명령으로 설정할 수 있습니다. nnn = 000으로 RTS 명령을 보내면 명령이 무시됩니다.

************************************************************************
이걸로 RX flag를 읽을 수 있을 것 같음
<READ STATUS instruction>
READ STATUS )는 명령은 메시지 수신 및 전송을 위해 자주 사용되는 일부 상태 비트에 단일 명령 액세스를 허용합니다.
MCP25625는 CS 핀을 낮춤으로써 선택되며, READ STATUS 명령 바이트 (그림 5-8 참조MCP25625로 전송됩니다. 명령 바이트가 보내지면 MCP25625는 상태를 포함하는 8 비트의 데이터를 반환합니다.
처음 8 비트가 전송 된 후에 추가 클럭이 전송되면 MCP25625는 CS 핀이 로우로 유지되고 SCK에서 클럭이 제공되는 한 상태 비트를 계속 출력합니다.
이 명령에서 반환 된 각 Status 비트는 해당 레지스터 주소와 함께 표준 READ 명령을 사용하여 읽을 수도 있습니다.
**************************************************************************

<BIT MODIFY>
BIT MODIFY 명령은 특정 상태 및 제어 레지스터에서 개별 비트를 설정하거나 지울 수있는 방법을 제공합니다. 이 명령은 모든 레지스터에서 사용할 수 없습니다. 이 명령을 사용할 수있는 레지스터를 결정하려면 4.0 절 "레지스터 맵"을 참조하십시오.
CS 핀을 낮춤으로써 부품을 선택하면 BIT MODIFY 명령 바이트가 MCP25625로 전송된다.
명령 다음에는 레지스터 주소, 마스크 바이트 및 마지막으로 데이터 바이트가옵니다. 마스크 바이트는 레지스터의 어느 비트가 변경 될지를 결정합니다. 마스크 바이트의 '1'은 레지스터의 비트가 변경되는 것을 허용하지만 '0'은 변경되지 않습니다 (그림 5-1 참조).


-----------------------------------------------------------------------------------------------------

EXTENDED 방식을 사용하려면 TXBxSIDL 레지스터에서 설정해줘야 한다.



